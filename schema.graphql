type Category @entity {
  id: ID!
  metadataHash: Bytes!
  tokens: [Token!]!
  indexPools: [IndexPool!]! @derivedFrom(field: "category")
}

type Proposal @entity {
  # id = proposalCount
  id: ID!
  state: String!
  proposer: Bytes!
  action: Bytes
  expiry: Int!
  for: BigInt!
  against: BigInt!
  votes: [Vote!]!
  targets: [Bytes!]!
  values: [BigInt!]!
  signatures: [String!]!
  description: String!
  title: String!
  calldatas:  [Bytes!]!
}

type Vote @entity {
  # id = transactionHash
  id: ID!
  voter: Bytes!
  option: Boolean!
  weight: BigInt!
}

type DailyDistributionSnapshot @entity {
  id: ID!
  active: BigInt!
  inactive: BigInt!
  delegated: BigInt!
}

type Token @entity {
  # id = address
  id: ID!
}

type DailyPoolSnapshot @entity {
  id: ID!
  timestamp: Int!
  tokens: [Token!]!
  balances: [BigInt!]!
  denorms: [BigInt!]!
  desiredDenorms: [BigInt!]!
  pool: IndexPool!
  feesTotal: BigInt
}

type PoolUnderlyingToken @entity {
  # id = poolAddress-tokenAddress
  id: ID!
  # Whether the token is initialized
  ready: Boolean!
  # Index pool the record is for
  pool: IndexPool!
  # Pool balance in the token
  balance: BigInt!
  # Minimum number of tokens the pool must hold to allow exits
  minimumBalance: BigInt
  # Token address
  address: Bytes!
  # Token decimals
  decimals: Int
  # Token name
  name: String
  # Token symbol
  symbol: String
  # Token address (old & now redundant, remove this)
  token: Token!
  # Denormalized weight
  denorm: BigInt!
  # Target denormalized weight
  desiredDenorm: BigInt!
}

type IndexPoolBalance @entity {
  # id = bal-poolAddress-ownerAddress
  id: ID!
  pool: IndexPool!
  balance: BigInt!
}

type Swap @entity {
  id: ID!
  caller: Bytes!
  tokenIn: Bytes!
  tokenOut: Bytes!
  tokenAmountIn: BigInt!
  tokenAmountOut: BigInt!
  pool: IndexPool!
  timestamp: Int!
}

type IndexPool @entity {
  # id = index pool address
  id: ID!
  # Category the pool indexes
  category: Category!
  # Pool ERC20 name
  name: String!
  # Pool ERC20 symbol
  symbol: String!
  # Number of tokens the pool should index at a time
  size: Int!
  # Contract that sells unboudn tokens
  tokenSeller: TokenSeller @derivedFrom(field: "pool")
  # Contract that initializes the pool's underlying tokens
  poolInitializer: PoolInitializer @derivedFrom(field: "pool")
  # Underlying tokens and balances
  tokens: [PoolUnderlyingToken!] @derivedFrom(field: "pool")
  # User balances of pool tokens
  balances: [IndexPoolBalance!] @derivedFrom(field: "pool")
  # Total fee revenue
  feesTotal: BigInt
  # Whether public swaps & joins are enabled
  isPublic: Boolean!
  # Whether the pool is still being initialized
  initialized: Boolean!
  # Daily snapshot of the pool status
  dailySnapshots: [DailyPoolSnapshot!]! @derivedFrom(field: "pool")
  # Total denormalized weight
  totalWeight: BigInt!
  # Total pool tokens that exist
  totalSupply: BigInt!
  # Maximum pool tokens that can be minted
  maxTotalSupply: BigInt!
  # Swap fee
  swapFee: BigDecimal
}

type TokenForSale @entity {
  # ID is tokenSellerAddress-tokenAddress
  id: ID!
  # Token seller the record is for
  tokenSeller: TokenSeller!
  # Address of the token
  token: Token!
  # Amount of tokens left to sell
  amount: BigInt!
}

type TokenSeller @entity {
  # ID is the address of the unbound token seller
  id: ID!
  # Address of the pool the seller is for
  pool: IndexPool!
  # Premium for the trader as a percent
  premium: Int!
  # Records of tokens being sold
  tokensForSale: [TokenForSale!] @derivedFrom(field: "tokenSeller")
}

type InitializerToken @entity {
  # ID is initializerAddress-tokenAddress
  id: ID!
  # Pool initializer the record is for
  poolInitializer: PoolInitializer!
  # Address of the token
  token: Token!
  # Target balance
  targetBalance: BigInt!
  # Balance of the pool initializer
  balance: BigInt!
  # Amount of tokens still needed
  amountRemaining: BigInt!
  # Token address
  address: Bytes!
  # Token decimals
  decimals: Int
  # Token name
  name: String
  # Token symbol
  symbol: String
}

type TokenContribution @entity {
  # ID is initializerAddress-txHash
  id: ID!
  transactionHash: Bytes!
  timestamp: Int!
  caller: Bytes!
  token: Token!
  amount: BigInt!
  credit: BigInt!
}

type TokenContributor @entity {
  # ID is initializerAddress-accountAddress
  id: ID!
  credit: BigInt!
}

type PoolInitializer @entity {
  # Initializer address
  id: ID!
  # Address of the pool the initializer is for
  pool: IndexPool
  # Tokens the initializer needs
  tokens: [InitializerToken!]! @derivedFrom(field: "poolInitializer")
  # Total amount of WETH users have been credited for
  totalCreditedWETH: BigInt!
}

type NdxStakingPool @entity {
  id: ID!
  startsAt: Int!
  isReady: Boolean!
  isWethPair: Boolean!
  indexPool: Bytes!
  stakingToken: Bytes!
  totalSupply: BigInt!
  rewardPerTokenStored: BigInt!
  periodFinish: Int!
  lastUpdateTime: Int!
  totalRewards: BigInt!
  claimedRewards: BigInt!
  rewardRate: BigInt!
}
